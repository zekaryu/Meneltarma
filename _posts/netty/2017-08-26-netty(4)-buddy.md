---
layout: post
title:  "netty 源码解读三 内存分配相关（2）-buddy 伙伴内存分配算法"
date:   2017-08-26 16:36:17 +0800
categories: [netty]
---

>本文主要介绍 buddy 伙伴分配算法。

## 算法

内存管理，特别是内存分配一直是操作系统一个基本问题。固定的划分模式会限制活跃进程的数量，而且如果进程请求的大小与可用的分割大小匹配效果不佳，会导致内存空间的使用效率很低。动态划分模式使得维护更复杂，包括内存合并的开销。而伙伴算法就是权衡折中的一种算法。最早由贝尔电话实验室的 Ken C Knowlton 在1965年的《A fast storage allocator》一文中提出。

在伙伴算法中，把用来分配的内存作为一整块2次幂大小的空间。当请求到达时，如果请求的大小大于初始大小空间的一半，那么整块内存都会被分配。否则，这个内存块会一分为二（这两块内存块互为伙伴，算法名即来源于此），这时候再一次判断请求的大小是否大于其中一块子内存块的一半，如果大于，则这块子块将被分配。如果小于，那么再将其中一个子块一分为二，以此类推，直到请求的大小大于分割后的子块的一半，若未找到，则直到分割系统允许的最小单位为止，然后再将相应内存块分配。

在此算法中，当一个进程结束时，分配给进程的内存块会被释放。只要有可能，一个未分配的内存块就会试图与其伙伴块合并以便形成一个更大的空闲内存块。如果两个内存块是由同一个父内存块一分为二产生的，那么他们就互为伙伴。

下面的例子展示了伙伴算法的具体分配过程。假设初始内存块大小为1024KB，表左侧为进程每次请求的内存大小。
![buddy allocator process](http://meneltarma-pictures.nos-eastchina1.126.net/netty/netty-4-buddy/buddy%20allocator%20process.png)

分配时优先考虑从低地址开始适配内存块。
