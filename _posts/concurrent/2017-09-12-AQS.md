---
layout: post
title:  "AQS 同步器框架翻译"
date:   2018-08-18 14:56:17 +0800
categories: [concurrent]
---

>JDK1.5之后java并发包基本上是基于AQS（AbstractQueuedSynchronizer）这个框架搭建的，AQS框架主要提供了对同步状态，阻塞和未阻塞线程/队列的原子性管理。本文主要探讨一下这个框架的逻辑依据，设计，实现，使用以及性能。

>最近想起java.util.concurrent并发包虽然平时开发一直会用到，但其实源码还没捋一遍，然后这个包的核心就是AQS，所以细读了一下源码作者Doug Lea的《The java.util.concurrent Synchronizer Framework》一文，然后将论文按自己的理解翻译了一下。

# 简介

Java 发布 JDK1.5 引入了 java.util.concurrent并发包，它是通过JCP的JSR166提出的一组中间级并发支持类构成的集合。包组件是由一个同步器集合构成的。这些同步器其实就是抽象数据类（abstract data type），它们可以维护同步器本身内部的同步状态（比如，是否被上锁），对同步状态进行更新和查看，至少有一个方法在适当的时候（比如被上锁的时候）导致调用它的线程阻塞，当其他线程更新同步状态时（比如释放锁的时候）阻塞线程也可以被允许恢复。可以举出很多例子比如：互斥锁，读写锁，信号量，栅栏，future，事件指示器（event indicator）和切换队列。

任何同步器都可以被用来实现另一个同步器。比如，重入锁可以用来构建信号量，反过来也可以。但是这么做在复杂度，开销和灵活性方面的表现都不会更好，所以这在工程角度充其量也就是个第二选择，而且在概念上完全让人提不起精神没有吸引力。如果某个组件从本质上来讲并不比另一个更加贴近原生层面，那么开发者就不应该武断地选择它作为基本单元来构建其他组件。而JSR166发起的AQS框架就不一样了，它提供的通用机制在并发包的大部分同步器中都使用了，我们自己也可以利用AQS来自定义符合自己特定需求的一些类。

# 必要条件
## 功能性
同步器具有两种方法：
+ 至少一个acquire操作，它可以阻塞调用线程，除非/直到同步状态允许线程继续执行；
+ 至少一个release操作，它会改变同步状态以至于可能这种改变会允许一个或多个阻塞线程解除阻塞状态。

java.util.concurrent 包并没有为同步器提供单个统一的API。其中一些通过普通接口定义（比如 Lock），而其他的同步器都有自己相应的API版本。所以这里说的acquire和release操作在这么多同步器中对应了一系列不同的名字和形式。比如 Lock.lock，Semaphore.acquire，CountDownLatch.await，FutureTask.get 这些方法都对应了这个AQS框架中的acquire操作。不过，为了支持一系列常用的使用选择，并发包在类之间维持延续了一致的约定。在有意义的情况下，每个同步器都支持一下条目：

+ 阻塞和非阻塞（比如tryLock）同步；
+ 可选的超时配置，这样调用的应用可以选择放弃等待；
+ 通过中断可以取消操作，通常分为两个版本，可取消的acquire操作，和不可取消的acquire操作。

同步器的种类根据是否管理其排他状态而分为两类。对于排他状态同步器，其每次只能有一个线程通过其阻塞点；对于共享状态同步器，可以一次允许多个线程运行通过。一般的锁当然只支持排他状态，但是对于如计数信号量这样的同步器，只要其计数限制允许，它就可以允许多个线程对它进行成功的acquire操作。为了AQS能更广泛地使用，框架对这两种模式都支持。

java.util.concurrent 包还定义了一个Condition 接口，用于支持监视器风格的 await/signal 操作，这些操作与排他锁 Lock 类型的类有关，而且Condition的具体实现类在本质上就与跟他相关的具体Lock类具有剪不断的关系。

## 性能目标
Java 内置锁（使用 synchronized 方法和代码块）性能方面的问题已经被长时间关注，也已经有大量论文还阐述其结构（比如参考文献[1] [3]）。不过，这些工作的主要关注点在于如何降低空间开销（因为任意java对象都可以被当做一把锁）以及如何在单核处理器的大部分单线程上下文环境下降低时间开销。对于同步器本身来说，这两个貌似都不是特别需要关注的：程序员只会在他们需要同步器的时候创建同步器，所以同步器的实例跟其他实力数量比起来肯定是微乎其微的，所以自然不用花大量精力为了这么点可能被浪费的空间去想办法对它进行压缩，此外同步器大部分都是在多线程环境下（特别是多核处理器）使用的，而在这种环境下，偶发的资源竞争本来就是在预料了之内的。所以常规JVM优化锁的策略主要是针对零竞争情况的，而没考虑对于其他情况而言有可能会是高不可预测性的“慢路径”[12]，对于严重依赖java.util.concurrent并发包的典型多线程服务端应用，这种策略显然是不对的。

与常规策略不同，AQS框架的主要目标不是降低空间时间开销，而是可伸缩性：甚至或者尤其是在同步器在被竞争的时候可预测地保证其效率。理想状态下，无论多少线程试图通过同步点，其开销都应该是一个常量。框架的主要目标之一是在某个线程被允许通过同步点而其他线程还没有通过的情况下，降低总的时间开销。但是同时也必须考虑到要平衡各种资源消耗，包括总的CPU时间需求，内存流量以及线程调度开销。比如，自旋锁的获取一般比阻塞锁需要的时间更短，但是它会进行空转，也会产生内存竞争，所以通常不太适用。

这些目标带来了同步器的两种使用方向。大部分应用要的是最大化总的吞吐量，容错性，最好再能保证一定概率减少饥饿情况的发生。但另一方面，对于资源控制这类应用，保证各个线程对资源访问的公平性远远更重要，它可以容忍较差的总吞吐量。可以说没有哪个框架能够代表用户在这两个相互冲突的目标之间作出选择；相反，该用哪种公平性策略应该视具体应用类型而定。

对于某些应用来说，无论同步器内部的设计实现如何完美精妙，也免不了会出现性能瓶颈。因此，框架必须对基本操作进行监视和检查以便用户可以及时发现和缓和瓶颈。这至少（也是最有用的）意味着要提供一种方式来决定有多少线程被阻塞。

# 设计和实现

同步器背后的基本思想相当直截了当。

acquire 操作的流程如下：
```
while (synchronization state does not allow acquire) {
  enqueue current thread if not already queued;
  possibly block current thread;
}
dequeue current thread if it was queued;
```
release操作的流程如下：
```
update synchronization state;
if (state may permit a blocked thread to acquire)
  unblock one or more queued threads;
```
对这些操作的支持需要以下三个基本组件：
+ 同步状态的原子性管理;
+ 线程的阻塞和解除阻塞;
+ 队列的维护。

虽然创建一个允许这三个组件独立实现的框架是可行的。但是，这样做既不会高效也不会提高可用性。比如，队列节点存储的信息必须与需要解除阻塞状态的线程，和依赖于同步状态特性的方法签名相吻合。

这个同步器框架最核心的决定是分别为这三个组件选择一个具体实现，同时又允许在它们在使用上有大量选项可以配置。这种做法有意地限制了其适用范围，但又提供了足够有效的支持，使得实际上我们并没有理由对于某些明明就很适用这个框架的案例也不去用它而却要从头开始构建其他同步器。

## 同步状态

AQS类仅用一个32bit的int数据来维护同步状态，并且暴露了getState，setState和compareAndSetState三个操作来访问和更新这个同步状态。这些方法反过来依赖于java.util.concurrent.atomic包的支持，这个包提供了JSR133（Java 内存模型）中兼容volatile关键字在读写上的语义，且通过对本地 compare-and-swap 或者 load-linked/store-conditional 指令的访问来实现 compareAndSetState，使得只有在得到期望得到的值时，同步状态才会被原子性地设置为一个新的值，也就是说这个compareAndSetState利用了Java内存模型中一些指令，在set新值得时候，还要比较原来的旧值有没有变化，如果有变化旧不能设置新值，因为说明状态可能被其他线程修改了，需要更新旧值，然后再次调用compareAndSetState。

严格地将同步状态限制为一个32bit的int变量是一个非常务实的决定。JSR166也提供了对于64bit long 类型变量的原子操作，但这些操作在满足条件的平台上其实还是必须使用内部锁机制来模拟，而且用它来做同步器性能也不会好。将来，可能会加入一个专门用64bit 表示同步状态（带有 long 类型的控制实参）的类。不过现在就将这个类引入这个包中的理由好像不够充分。java.util.concurrent 包中只有一个同步器也就是CyclicBarrier可能会需要更多比特数来维护同步状态，所以这个类使用了锁（就像这个包中更高等级的工具类也是这样）。

基于AQS的具体类必须根据暴露的与状态相关的方法实现tryAcquire和tryRelease方法，以便控制acquire和release操作。当同步状态满足条件被获取时，tryAcquire方法必须返回true；当新的同步状态允许后续的acquire操作时，tryRelease方法也必须返回true。这两个方法都支持接受一个int参数用来传递想要设置的状态；比如对于可重入锁，为了在条件等待return之后重新获取锁，需要重新建立循环技术。很多同步器并不需要这么一个参数，所以对它直接忽略即可。

## 阻塞

在JSR166之前，用来阻塞和解除阻塞状态线程都是基于Java内置的监视器机制，并没有可用的Java API类创建的同步器来达到相同的目的。Thread.susped和Thread.resume时唯一的可选项，但由于他们会遇到解决不了的竞态问题，所以不可用：如果一个没有阻塞的线程在另一个阻塞线程执行suspend方法之前执行了resume方法，那么这个resume方法不会有任何效果。

java.util.concurrent.locks 包中的LockSupport类提供了解决这个问题的方法。调用LockSupport.park方法会阻塞当前线程，除非/直到LockSupport.unpark方法被调用。（伪唤醒也被允许，意思是先调用unpark也是可以的，没有说先调用unpark然后调用park，unpark就不会有作用。）对unpark的调用没有记录调用次数，所以在park之前不管调用多少次unpark，都只会对一个park操作进行解除阻塞。此外，这个原则对每个线程而言的，不是对每个同步器。一个对某个新的同步器调用park操作的线程有可能在调用之后立即return而感觉不到它被阻塞过，因为有可能程序中有之前遗留的未被消费的unpark操作。但是在缺少unpark的情况下，它的下一次park调用就会阻塞了。举个例子假如先对某线程调用两次unpark，然后再调用两次park，那么第一次park会不会阻塞，线程立即返回并将unpark次数清零，第二次park会阻塞线程。虽然可以显示的清楚这种阻塞状态，但不值得我们这么做。在需要的时候多次调用park更有效率。

这种简单的机制在某种层面上与Solaris-9的线程库，WIN32中的“可消费事件”，以及Linux中的NPTL线程库相似。这也对应在这些最常见的运行Java的平台上有各自的有效的实现。（不过，目前在Solaris和Linux上的Sun Hotspot JVM 引用实现实际上是用pthread condvar来适配已经存在的运行时设计的。）park方法还支持可选的相对和绝对超时配置，且被集成到了JVM的Thread.interrupt支持中——unpark操作可以实现对线程的中断。

## 队列

此框架的核心是对所有阻塞线程队列的维护管理，这些队列被严格限定为必须是先进先出的队列。如此，框架也就不支持基于优先级的同步了。

近来，对于同步队列的最佳选择是使用自身没有用底层锁构造的非阻塞数据结构这一点，少有争议。基于此，目前有两个候选项：Mellor-Crummey，Scott锁（MCS锁）[9] 的变体和 Craig，Landin，and Hagersten (CLH) 锁[5][8][10]的变体。在之前，CLH锁仅使用于自旋锁。不过，对于本同步器框架，CLH锁似乎比MCS更适合，因为CLH锁更适合于处理取消（cancellation）和超时，所以将其选为框架的基础。最终的设计结果与原版的CLH结构已经大相径庭，所以还需后续解释说明。

CLH结构的队列其实不太像个队列，因为它的出队入队都与它所为一把锁这个用途紧密相关。它是个链表队列，通过两个自动可更新域head和tail访问，head和tail初始化时都指向一个空节点。

![aqs-queue-node](http://meneltarma-pictures.nos-eastchina1.126.net/concurrent/AQS/aqs-clh-queue-node.png)
<center>图1 CLH 队列</center>

新节点node，通过一个原子操作入队：
```
do{
  pred = tail;
} while(!tail.compareAndSet(pred, node));
```
每个节点的“释放”（release）状态都被保存在它的前驱节点中。因此，自旋锁所为的“自旋”过程如下：
```
while(pred.status != RELEASED); // spin
```
自旋后的出队操作只需将head 指向刚刚获取锁的节点：
```
head = node ;
```
CLH的优势在于快速的入队和出队，无锁操作，无障碍（甚至在竞争状态下，也会有一个线程赢得一次插入竞争而不被阻挡）；检测是否有线程正在等待也很快（只要检测head与tail是否相同）；而且释放状态与它表示的节点不在一个结构中，这样会避免某些内存竞争。

在原始版本的CLH锁中，节点之间是没有连接在一起的。在自旋锁中，pred变量可以作为本地变量保存。Scott 和Scherer[10]的论文表明通过显式维护前驱节点域，CLH锁可以处理超时很其他形式的取消：如果一个节点的前驱节点被取消了，这个节点可以向上滑动使用前面一个节点的状态域。

将CLH队列用于阻塞同步器需要的其主要的调整是提供一种定位某个节点的后继节点的有效方法。在自旋锁中，一个节点只需要修改它自己的状态，就会在下一次自旋过程中被其后继节点注意到，所以不需要连接。但是在阻塞同步器中，一个节点需要显示唤醒（unpark）其后继结点。

AQS队列节点包括一个指向其后继节点的next连接。但因为不存在compareAndSet这样可以对双向链表进行无锁原子插入的技术，所以作为插入操作的一部分，这个连接的设置不是原子的；它只是在插入操作完成后被简单赋值：
```
pred.next = node;
```
next连接只是被当做一种优化思路。如果通过next域发现节点的后继者不存在（或者被取消了），那么可以从tail开始反向查找链表，使用pred域来检测后继者是否真的存在。

第二个调整是每个节点中保存的状态域用于阻塞控制而不是自旋。在同步器框架中，只有调用具体子类中的tryAcquire获得通过，队列中的线程才能返回；只有一个“released”的标志位是不够的。但是还需要一些控制来保证活跃线程处于队列头的时候只被允许调用tryAcquire操作；同等条件下acquire可能会失败，然后继续阻塞。这不需要获取节点的状态标识因为通过检测节点的前驱者是否是head就能决定权限。而且与自旋锁不同，在杜宇head以保证复制时不会有很多内存竞争。不过，取消状态仍然必须在显示在状态域中。


# 参考文献

1.[The java.util.concurrent Synchronizer Framework](http://gee.cs.oswego.edu/dl/papers/aqs.pdf)
